#!/bin/bash
#$ -o ${run_path}/logs/$JOB_NAME_$JOB_ID_init.out
#$ -e ${run_path}/logs/$JOB_NAME_$JOB_ID_init.err

set -e

if (( cluster == 1 ))
then
  cluster=true
  module purge
  module load intel/18.0u1 netcdf-4
  #~ if [ -d $SCRATCH/parallel_studio_2019 ]
  #~ then
    #~ module purge
    #~ export NETCDF="$SCRATCH/netcdf"
    #~ source ${home_dir}/parallel_studio_2019/parallel_studio_xe_2019.4.070/bin/psxevars.sh
  #~ fi
else
  cluster=false
fi

ulimit -s unlimited

code_dir=$(pwd)

echo "jobs: $jobs"
jobs=(${jobs})
nslots=(${nslots})
wrfv=(${wrfv})

echo "job ID : $JOB_ID"
echo

 
si=0
pool=false
if (( ${#jobs[@]} > 1 )) && (( ${pool_jobs} == 1 ))
then
  pool=true
  if $cluster
  then
    qs=$(qstat -t)
    hosts=$(python ${code_dir}/pool/get_hosts.py "$JOB_ID" "$qs")
    hosts=(${hosts})
    echo "hosts ${hosts[*]}"
  fi
fi

for (( i=0; i<${#jobs[@]}; i++ ))
do
  cd ${run_path}/WRF_${jobs[$i]}
  #redirect logs to file
  exec 1> "run.log"
  exec 2> "run.err"

  echo "Running job: ${jobs[$i]}"
  nsi=${nslots[$i]}
  wrf_dir_i=${wrfv[$i]}
  echo "slots: $nsi "

  if (( nsi > 1 ))
  then
    echo "parallel"
    if $pool && $cluster
    then
      echo "si $si"
      hostsi=${hosts[@]:$si:$nsi}
      echo "on hosts: $hostsi"

      H=$(python ${code_dir}/pool/get_hosts_set.py "$hostsi")
      python ${code_dir}/pool/rankfile.py  "${hosts[*]}" "$si" "$nsi" > rankfile.$JOB_ID
      cat rankfile.$JOB_ID

      mpiexec -H $H -rf rankfile.$JOB_ID -mca rmaps_rank_file_physical 1 -np $nsi -v -report-bindings -display-map -display-allocation ./wrf.exe || true &
      si=$((si + nsi))
      sleep 20

    else
      mpiexec -np $nsi -v ./wrf.exe || true  &
    fi
  else
    echo "serial run"
    ./wrf.exe || true  &
  fi
  echo 
  echo
done

for (( i=0; i<${#jobs[@]}; i++ ))
do
  # if SGE is used or wait=True is set: wait for job to finish
  if [ -n "${SGE_STDOUT_PATH}" ] || (( $wait==1 ))
  then
    wait
    #append rsl.error.0000 to run.log
    cd ${run_path}/WRF_${jobs[$i]}
    if [[ -f rsl.error.0000 ]]
    then
      cat rsl.error.0000 >> run.log
    fi
  fi

  if (( restart == 1 ))
  then
    echo "Concatenate output from original and restarted run"
    python -c "import misc_tools; misc_tools.concat_restart('$outpath', '${jobs[$i]}')"
  fi
done

if $cluster
then
  qstat -j $JOB_ID > qstat.info
fi
